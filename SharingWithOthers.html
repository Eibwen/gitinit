<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title></title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="css/normalize.css">
        <link rel="stylesheet" href="css/main.css">
        <script src="js/vendor/modernizr-2.6.2.min.js"></script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
        <![endif]-->

        <!-- Add your site or application content here -->
        <h1>Git`in It</h1>
        <h2>Understanding Distributed Version Control with Git.</h2>

        <h3>Sharing with the Team</h3>

        <p>Before you can share with others, you need to decide where and how you will be sharing code.  Everything that has been done up to this point in the tutorial has happened on a single machine.  This is a point that sometimes gets missed by people who have used revision control software in the passed.  The commits that we have been doing have not been copying our changes to a server.  The good part of this is that commits are very fast and we can do them when we do not have access to the "server".  The other side of it is that a commit does not save the information to another machine.  This means that after a commit others we are working on still connot "see" our changes.</p>

        <h3>Git Server Options</h3>

        <p>To start I would recomend using a service like <a href="https://github.com/">GitHub</a>.  This frees you from having to learn about deployment options and server setup.  Alternately you may have a Git server that has already been setup by your employer or someone else on your team.  Obviously in this case you will use that server.  If you are determined to setup your own server, I recomend getting a package like GitHub offers that will handle the complete installation for you.</p>

        <h3>Working with remotes</h3>

        <p>As we have already discussed the repository is actually on your local computer.  In order to work with others the repository needs to be someplace that everyone can get access.  I will not walk through getting a local repository into a server repository (thought this is possible), instead let us assume that you have put the repository onto a server.  This becomes one of the remotes for your local repository.</p>

        <code>Git clone [URL] [folder]</code>

        <p>For example</p>

        <code>Git clone ssh://git@vm-git/GitinitWebSite.git C:\Source\GitinitWebSite</code>

        <p>We talked about creating a local repository by running the <code>git init</code> command.  When you are working with a remote server you will create the repository on the server (however it makes sense for your server) and then clone the repository.  This will also setup the remote relationship automatically.</p>
        
        <p>Like <code>git init</code> this results in a repository on your local machine.  A cloned repository is nearly identical to a locally initialized repository.  The one difference is that the cloned repository will have a remote listed showing the <code>origin</code> of the repository.  The origin is important for commands that work between repositories.</p>
        
        <code>git fetch [repository]</code>
        
        <p>This command requests any changes from the repository specified.  If the local repository was cloned from the remote repository, then you can leave the repository name off, <code>git fetch</code>.  Though this retrieves any commits that are on the remote server, but not on yours, it does not resolve the two different lines of development.</p>
        
        <h3>Distributed Development Reality</h3>
        
        <p>When you are working on the <code>master</code> branch on your local machine, it is likely that other people are pushing changes to the remote repository <code>master</code> branch.  One way to think of this is as if there were two branches.  Development on two different branches can be merged.  This results in a history graph that looks like this:</p>
        
        <img src="Merge.png" />

        <p>If we actually had multiple branches, that would be fine, but we are working on the same branch.  So we need a new method of getting two different lines of development aligned.  For Git the command is <code>git rebase</code>.  This takes the commits you have made to your local <code>master</code> branch and apply them to the remote <code>master</code> branch.  This leads to a linear history like this:</p>
        
        <img src="Rebase.png" />
        
        <p>But what about the <code>git pull</code> command?  <code>git pull</code> is like issuing a <code>git fetch</code> followed by a <code>git merge</code>.  Though this will work you will find most shops use rebase for work on the same branch.  Merging is used for bringing branches back together.</p>
        
        <h3>Don't Cross the Streams</h3>
        
        <p>Merging and Rebasing work fine together as long as you don't use both commands on the same commits.  The repository will become corrupt if you do.  Though this would be an uncommon mistake it is worth noting the risk.</p>
        
        <h3>Who's The Master?</h3>
        
        <p>For most Git setups, <code>master</code> is the name of the trunk or main branch in a repository.  If no other branches are created, then all work will be on the <code>master</code> branch.</p>
        
        <h3>Now Back to Our Regularly Scheduled Program</h3>
        
        <p>More explanation is probably in order.  Let's get back to understanding what happens when bringing changes from to repositories together.  Let's consider the following set of changes on your local <code>master</code> branch:</p>
        
        <code>
        9227e1 --- ca82493 --- ca93a4 --- 495254 (master)
        </code>
        
        <p>Let's say that development on the origin server looks like this:</p>

        <code>
        9227e1 --- ca82493 --- 390b06 --- 181df7 (master on origin)
        </code>
        
        <p>After a fetch your local repository will look something like this:</p>

        <code>
        9227e1 --- ca82493 --- ca93a4 --- 495254 (master)
                         \ --- 390b06 --- 181df7 (origin/master)
        </code>
        
        <p>Note that these "branches" are actually both the <code>master</code> branch.  So we need to get them back together as a single branch.</p>
        
        <code>git rebase</code>
        
        <p>This tells Git that we want all for commits on a single line.  So Git applies the local commits to the <code>origin/master</code>.  If there are no conflicts then everything happens automatically.  If one of your changes effects the same section of a file that was changed on the origin, then you will be asked to merge the changes.  Once you are done merging you will need to continue the rebase.</p>
        
        <code>git rebase --continue</code>
        
        <p>Now git will continue to apply your local commits to the <code>origin/master</code> branch.  Once the rebase is done your local repository will look something like this:</p>
        
        <code>
        9227e1 --- ca82493 --- ca93a4 --- 495254 --- f62e30 --- a993fe (master)
                                      \ --- (origin/master)
        </code>
        
        <p>Now that you have your new set of commits, you obviously need to test them.  Assuming you feel that the changes are sound, you will want to share them with the rest of the world.  That command is <code>git push</code>.  The advantage of the work that you just did to resolve any conflicts is that there will not be any on the remote machine.  So now the local repository will look like this:</p>

        <code>
        9227e1 --- ca82493 --- ca93a4 --- 495254 --- f62e30 --- a993fe (master)(origin/master)
        </code>

        <h3>What's With The Branch Names</h3>
        
        <p>The names of the branches (master) and (origin/master) represent two different branches in your local repository.  The master branch is the local trunk of your repository.  The origin/master branch is a <b>tracking branch</b> of the remote (origin) master branch.  So when you fetch changes from the remote they go on this branch.  Tracking branches are important for working with remotes.</p>
        
        <h3>What's With the Numbers?</h3>
        
        <p>We mentioned the commit numbers previously.  They are SHA1 hashes of the commit changes.  As such they are unique.  This is important for a distributed system.  This way each system can assign commit numbers without being concerned about a conflict with another system.  That is why the commits are identified by these really long numbers such as <code>fa047ea4ba24314ce9e0225a766ab0ea401f8ab1</code>.  The good news is that you never have to type in the whole number.  You only need to enter enough of the number to be unique on your local system.  Six digits is almost always sufficient, so you will see the commit IDs written as the first six numbers like this <code>fa047e</code>.  Any command that is looking for a commit will also take this shorthand version.</p>
        
        <p>There is another shorthand version of referring to commits relative to the HEAD of the the current branch.  The HEAD of the current branch is the the final commit on that branch.  You can then refer to commits relative to the HEAD.  So the commit 2 before the HEAD can be referred to as HEAD~2.  This should look familiar from the <a url="FixingMistakes.html">Fixing Mistakes</a> lesson.</p>
        
        <h3>Where Were We?</h3>
        
        <p>Getting back to what we were talking about before, the flow of commands is:</p>
        
        <ul>
          <li><code>git fetch</code></li>
          <li><code>git rebase</code></li>
          <li>Check Your Changes</li>
          <li><code>git push</code></li>
        </ul>
        
        <p>You need to fetch and rebase before you can push your changes.  Git will not allow you to send your commits to a remote server unless you have all of the commits from that server resolved.  In this way you must resolve any conflicts prior to pushing them back to the server.  This is more than just a minor point of reference with Git.  It is integral to why Git can work in a distributed manner.  Most SCM tools allow the resolution of conflicts to be passed downstream.  With Git each user is required to resolve any conflicts before they can be shared with other users.  This means that though there is no guarantee that the changes will "work" it is guaranteed that no one downstream will need to resolve changes.</p>
        
    </body>
</html>
