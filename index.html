<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title></title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="css/normalize.css">
        <link rel="stylesheet" href="css/main.css">
        <script src="js/vendor/modernizr-2.6.2.min.js"></script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
        <![endif]-->

        <!-- Add your site or application content here -->
        <h1>Git`in It</h1>
        <h2>Understanding Distributed Version Control with Git.</h2>

        <h3>Overview</h3>
        <p>This site is was created to help people to understand distributed version control systems (DVCS) and their use.  I am using Git as it has become the de facto standard for DVCS.  DVCS are not only a better form of revision control, but a different approach.  This means that you need to think differently about the changes you are making when using a DVCS than you would with a revision control tool.  So let's start with a little retooling of how you think about history.</p>

        <h3>Revision Control to Version Control</h3>

        <p>Note: If you have never used a revision control system before (SVN, CVS, Perforce, ClearCase, TFS, etc.) then you can skip this part and go on to <a href="#Version">Versions</a>.</p>

        <p>A typical revision control system tracks changes to specific files.  So if you are working on your Web Site, perhaps you change the text of your index.html page.  Then you commit that change to the repository and create a new revision of the index.html file.  This works fine for many changes.  Let's say that you have decided to change the line under your's sites name.  First you change the template header include (that all of your pages use to include this line), but when you look at it you realize that you need more contrast so you change the css file that has the colors for this text.  Finally on looking at it some more you realize that the border color on your logo image is too similar to the new text color and so you decide to change the logo image as well.  At this point this one change has required changes to three different files (HTML Header template, css file and logo image).  Although a revision control system will allow you to track each one of those changes they do not provide an easy way to tie those changes together.  They track the revisions, not the versions.</p>

        <a name="Version"></a><H3>Thinking about Versions</H3>
        <p>So let's consider this change again.  Changing the text under the site name on your web site.  The HTML Header template file changes with the new text, the css file changes to use new colors for the new text and the site logo changes to have a different colored border.  You and I would see the changes to all three files as a single change tot he web site.  Version control systems also see this as a single change.  When you commit this change you will commit all three files together.  In this way others can see that the change required editing three different files, because they are all included in the commit.  This makes it easier to look at the history of the repository and understand what is going on.  People often refer to the release manager as an example of who benefits, but the programmer/content author benefits as well.  Many of us have had to look back 6 month, a month, a week, even a couple of hours later and had to understand what we were trying to do when the change was commited.  Because the change includes all the files that were required to change for the version it is easier to understand what we were trying to accomplish.  It's worth noting that this only works when the commit's are "clean".  That is the commit contains all the files that were part of the change and nothing else.  When you do this the history of the versions becomes more a story of what you are trying to accomplish and less 1,000 details that need to be organized.</p>

        <h3>Distributed Control</h3>
        <p>The other aspect of a DVCS that is often difficult to understand is the distributed nature.  Historically revision control systems had a single repository to store the history of changes.  With distributed version control systems every user has a copy of that repository.  Furthermore there is no requirement that they every push their local versions to a common repository.  Obviously if you are working with others at some point you are going to want to share your work, but that choice is seperate from the choice of when to commit work to the repository.  In a distributed system you make changes and commit them to your local repository.  Since all of this is on your local machine, you can do this anytime you like.  People often use the example of commiting changes on an airplane.  For me this does not come up very often, but I do enjoy working at a local park when I can.  Since the repository is local I can commit different versions through the time I spend at the park.  Then I can decide later to share those versions with the rest of the team, like when I get back to the office.  Another use for the distributed aspect is working on sub teams.  Let's say that the web site I have been talking about is being worked on by a team of 14 people.  Let's say that there is a web master and graphic designer.  Then the rest of the team is broken in groups of subject matter experts that have two or three people each.  Each group can have their own repository that they share their changes to.  Then others in the group can review them, possibly make changes, etc.  Finally when the group thinks their content is ready they can push their changes to a central repository used by the whole team.  Of course these groups will also be pulling content from this central repository to there group repositories from time to time so they can keep up on what others on the time are doing.  There are many workflows that become possible with the distributed nature of Git and other DVCS'.  They take a little getting used to, but it definitely opens up possibliities.</p>

        <h3>Git Tax</h3>
        <p>By now you may be thinking that it sounds like there is a lot more stuff to do with a DVCS than with a "traditional" revision control system.  The truth is there is a lot more stuff that you can do and a little more stuff that you have to do.  There is some additional overhead (more commands, more choices) with a DVCS, but that provides a great deal more flexibility.</p>
        <p>Enough overview, let's take a look at how this works.</p>

        <a href="GettingStarted.html">Getting Started</a>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
        <script>window.jQuery || document.write('<script src="js/vendor/jquery-1.10.2.min.js"><\/script>')</script>
        <script src="js/plugins.js"></script>
        <script src="js/main.js"></script>

        <!-- Google Analytics: change UA-XXXXX-X to be your site's ID. -->
        <script>
            (function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
            function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
            e=o.createElement(i);r=o.getElementsByTagName(i)[0];
            e.src='//www.google-analytics.com/analytics.js';
            r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
            ga('create','UA-XXXXX-X');ga('send','pageview');
        </script>
    </body>
</html>
