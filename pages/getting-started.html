<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width">
    <title>Getting Started - Gitin' It
    </title>
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic|Anonymous+Pro:400,700,400italic,700italic|Merriweather:400,700,300">
    <link rel="stylesheet" href="../css/main.css">
  </head>
  <body class="article-detail">
    <header class="header">
      <div class="content-wrap">
        <h1>Getting Started</h1>
      </div>
    </header>
    <div id="content">
      <div class="content-wrap">
        <article class="article">
          <section class="content"><h3 id="getting-to-know-git">Getting to Know&nbsp;Git</h3>
<p>Before we get started we need to introduce ourselves to Git.  This is important because beyond tracking what has changed, Git is also going to track who made the&nbsp;changes.</p>
<pre><code>git config
</code></pre><p>Git has a configuration where it tracks things like who you (the user) are.  You can modify this configuration using the <code>git config</code> commands.</p>
<pre><code>git config user.name Fred Foyle
git config user.email fred.foyle@example.com
</code></pre><p>These commands will identify who you are to Git.  They will store this information in the current repository which may be fine.  If you don’t want to have to keep entering this information for each repository however you can run the commands with the global&nbsp;flag:</p>
<pre><code>git config --global user.name Fred Foyle
git config --global user.email fred.foyle@example.com
</code></pre><p>Now Git will remember these settings for all repositories for you.  This is probably how you want to edit most of the config settings (globally) in most circumstances.  While we are editing the configuration we should tell Git what editor we want to use with Git.  This command looks like&nbsp;this:</p>
<pre><code>git config --system core.editor C:\Windows\notepad.exe
</code></pre><p>Note in this case we have updated the system configuration which will apply to anyone using Git on this machine.  Git looks for the first place to find a configuration setting.  It looks first in the repository config (no command line switch), then your user config (—global) and finally in the system config (—system) file.  There are a couple more settings you should tend to.  Git does not have a tool for showing file differences.  You can use any tool that you&nbsp;like.  </p>
<pre><code>git config --global merge.tool vimdiff
</code></pre><p>  Finally, you may want to set how Git handles end of line (<span class="caps">EOL</span>), characters.  Anytime you are sharing text files across multiple computers there is the question of how lines are ended.  If you do not know there are differences to the characters that mark the end of a line on different computers.  The trick is that you don’t want Git telling you that all the lines in the file are different because someone on a different system edited the file and their editor replaced all the end of line markers.  Git can handle this situation for you.  The autocrlf feature will convert Windows line ending to Unix line ending when the files are put back into the&nbsp;repository. </p>
<pre><code>git config --system --core.autocrlf true
</code></pre><p>Now that Git is setup, let’s add some&nbsp;files.</p>
<pre><code>git init
</code></pre><p>To start working we need a repository.  Git creates the repository when you run the <code>git init</code> command.  Git will create a folder called <code>.git</code>.  There is nothing in this folder you need to look at.  It is important that this folder is being backed up somehow as all of the change history that is being tracked is in this&nbsp;folder.</p>
<p>  So now that we have run <code>git init</code> we have a repository but there are no files in it.  Not very&nbsp;interesting.</p>
<pre><code>Git add
</code></pre><p>  Not surprisingly the command to add files in git is <code>git add</code>.  This adds the files to a staging area.  Since Git was designed around a command line interface (<span class="caps">CLI</span>) there needed to be a way to select the files you want to act on.  This staging area is that list.  People will often use <code>get add .</code> or <code>git add -A</code>.  The first command <code>git add .</code> will add files that are new or that have been modified to the staging area.  <code>Git add -A</code> will add new files, modified files and note any files that have been removed.  For this tutorial we will use a shared directory for our examples.  This directory will have a line for each person with their name, phone number and file name of their picture.  Let’s say Fred Foyle is starting this directory, so he creates a file with his information and his&nbsp;picture.</p>
<p>Now that our list of files has been staged we can “look” at the list using the <code>git status</code> command.</p>
<pre><code># On branch master
#
# Initial commit
#
# Changes to be committed:
#   (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)
#
#    new file:   Directory.txt
#    new file:   ffoyle.jpg
#
</code></pre><p>  Note that Git shows that the files are new and have been added to the staging area.  It also notes that we are on branch master, which is the default main branch of a Git&nbsp;repository.</p>
<p>  Once we have our changes added to the staging area, we commit them to the&nbsp;repository.</p>
<pre><code>git commit -m &quot;Initial commit&quot;
</code></pre><p>  This command will add the changes we had staged to the repository with the comment message <em>Initial Commit</em>.  The output will look something like&nbsp;this:</p>
<pre><code>[master (root-commit) 7576855] Initial commit
 2 files changed, 1 insertion(+)
 create mode 100644 Directory.txt
 create mode 100644 ffoyle.jpg
</code></pre><p>  A couple of things to note.  The <code>[master  7576855]</code> tells you that the commit was added to the master branch (more on branches later) and the commit has an <span class="caps">ID</span> of 7576855.  The ID will become important when we start <a href="../pages/sharing-with-others.html">SharingWithOthers</a>.  Note that the commit records all the changes, in this case both files.  Also note that though Git allows for adding binary files (like ffoyle.jpg) it will not track differences in binary&nbsp;files.</p>
<p>  Now that we have a start our man Fred decides to add his son to the directory.  After adding his son’s name to the directory Fred copies a picture also.  Then if you run git status you will see something like&nbsp;this:</p>
<pre><code># On branch master
# Changes not staged for commit:
#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)
#
#    modified:   Directory.txt
#
# Untracked files:
#   (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)
#
#    MichealF.jpg
no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre><p>  See that git reminds you that you will need to add the files.  So let’s do&nbsp;that:</p>
<pre><code>git add Directory.txt
git add MichealF.jpg
</code></pre><p>  Now <code>git status</code> shows that the files are both in the&nbsp;index.</p>
<pre><code># On branch master
# Changes to be committed:
#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
#
#    new file:   MichealF.jpg
#    modified:   Directory.txt
#
</code></pre><p>  Now we just need to commit these&nbsp;changes.</p>
<pre><code>git commit -m &quot;Added Micheal&quot;
</code></pre><p>  The output looks something like&nbsp;this:</p>
<pre><code>[master f6d26b1] Added Micheal
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 MichealF.jpg
</code></pre><p>  So <code>git add .</code> will add all the files and <code>git add MichealF.jpg</code> adds that one file.  If you have several files to add it may become tedious to add them one at a time, so git allows you to add them&nbsp;interactively.</p>
<pre><code>git add -i
</code></pre><p>  Then follow the prompts.  Experience with other version control systems suggests that these are very small changes to be committing.  With Git it is better to make many small commits.  We will learn later how these can be made more meaningful.  Also because these changes are committed to the repository on your machine no one else will see them until you are ready to share them.  Note that you do not have to plan for the files you wish to modify.  You just make changes and Git notices those changes, you stage them and then commit them.  If you are working on your own this is all the workflow that you need.  As with any endeavor you will make mistakes from time to time, so let’s talk about <a href="../pages/fixing-mistakes.html">fixing mista<span style="text-decoration: line-through;">t</span>kes</a>.</p>
</section>
        </article>
      </div>
    </div>
    <footer>
      <div class="content-wrap">
        <div class="nav"><a href="../pages/before-the-beginning.html" class="previous">&#171; Previous</a><a href="../" class="index">Home</a><a href="../pages/fixing-mistakes.html" class="next">Next &#187; </a>
        </div>
      </div>
    </footer>
  </body>
</html>